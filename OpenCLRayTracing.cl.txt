<code><br>const int kAntiAliasingSamples  = 2;<br>const int kMaxTraceDepth = 2;<br>const float kMaxRenderDist = 1000.0f;<br><br>struct Material{<br>	/* 0 - Standard diffuse color, 1 - Compute 'Chessboard' texture */<br>	int computeColorType;<br>	float4 color;<br>	float reflectivity;<br>	float refractivity;<br>};<br><br>struct Material createMaterial()<br>{<br>	struct Material m;<br>	m.color = (float4)(1,1,1,1);<br>	m.computeColorType = 0;<br>	m.reflectivity = 0;<br>	m.refractivity = 0;<br>	return m;<br>}<br><br>struct Sphere{<br>	struct Material* m;<br>	float3 pos;<br>	float radius;<br>};<br><br>struct Plane{<br>	struct Material* m;<br>	float3 normal;<br>	float3 point;<br>};<br><br>struct Ray{<br>	float3 origin;<br>	float3 dir;<br>};<br><br>struct Light{<br>	float3 pos;<br>	float3 dir;<br>	bool directional;<br>	float4 color;<br>};<br><br><br>struct Scene{<br>	struct Sphere spheres[10];<br>	int spheresCount;<br>	<br>	struct Plane planes[10];<br>	int planesCount;<br>	<br>	struct Light lights[10];<br>	int lightsCount;<br>	<br>	struct Material standardMaterial;<br>};<br><br>float3 reflect(float3 V, float3 N){<br>	return V - 2.0f * dot( V, N ) * N;<br>}<br><br>float3 refract(float3 V, float3 N, float refrIndex)<br>{<br>    float cosI = -dot( N, V );<br>    float cosT2 = 1.0f - refrIndex * refrIndex * (1.0f - cosI * cosI);<br>	return (refrIndex * V) + (refrIndex * cosI - sqrt( cosT2 )) * N;<br>}<br><br>bool raySphere(struct Sphere* s, struct Ray* r, float* t)<br>{<br>	float3 rayToCenter = s-&gt;pos - r-&gt;origin ;<br>	float dotProduct = dot(r-&gt;dir,rayToCenter);<br>	float d = dotProduct*dotProduct - dot(rayToCenter,rayToCenter)+s-&gt;radius*s-&gt;radius;<br><br>	if ( d &lt; 0)<br>		return false;<br><br>	*t = (dotProduct - sqrt(d) );<br><br>	if ( *t &lt; 0 ){<br>		*t = (dotProduct + sqrt(d) ) ;<br>		if ( *t &lt; 0){<br>			return false;<br>		}<br>	}<br><br>	return true;<br>}<br><br>bool rayPlane(struct Plane* p, struct Ray* r, float* t)<br>{<br>	float dotProduct = dot(r-&gt;dir,p-&gt;normal);<br>	if ( dotProduct == 0){<br>		return false;<br>	}<br>	*t = dot(p-&gt;normal,p-&gt;point-r-&gt;origin) / dotProduct ;<br><br>	return *t &gt;= 0;<br>}<br><br>float intersect(struct Ray* ray, struct Scene* scene, void** object, int* type)<br>{<br>	float minT = kMaxRenderDist;<br>	<br>	for(int i = 0; i &lt; scene-&gt;spheresCount; i++){<br>		float t;<br>		if ( raySphere( &amp;scene-&gt;spheres<span style="">, ray, &amp;t ) ){<br>			if ( t &lt; minT ){<br>				minT = t;<br>				*type = 1;<br>				*object = &amp;scene-&gt;spheres<span style="">;<br>			}<br>		}<br>	}<br>	<br>	for(int i = 0; i &lt; scene-&gt;planesCount; i++){<br>		float t;<br>		if ( rayPlane( &amp;scene-&gt;planes<span style="">, ray, &amp;t ) ){<br>			if ( t &lt; minT ){<br>				minT = t;<br>				*type = 2;<br>				*object = &amp;scene-&gt;planes<span style="">;<br>			}<br>		}<br>	}<br>	<br>	return minT;<br>}<br><br>float4 raytrace(struct Ray* ray, struct Scene* scene,int traceDepth)<br>{<br>	void* intersectObj = 0;<br>	int intersectObjType = 0;<br>	float t = intersect( ray, scene, &amp;intersectObj, &amp;intersectObjType);<br>	<br>	float4 color = (float4)(0,0,0,0);<br>	if ( t &lt; kMaxRenderDist ){<br>		float3 intersectPos = ray-&gt;origin+ray-&gt;dir*t ;<br>		float3 normal;<br>		<br>		struct Material* m = 0;<br>		<br>		if ( intersectObjType == 1 ){		<br>			normal = normalize(intersectPos-((struct Sphere*)intersectObj)-&gt;pos);<br>			m = ((struct Sphere*)intersectObj)-&gt;m;<br>		}<br>		else if (intersectObjType == 2 ){<br>			normal = ((struct Plane*)intersectObj)-&gt;normal;<br>			m = ((struct Plane*)intersectObj)-&gt;m;<br>		}<br>		<br>		if ( !m ){<br>			m = &amp;scene-&gt;standardMaterial;<br>		}<br>		<br>		float4 diffuseColor = m-&gt;color;<br>		<br>		if ( m-&gt;computeColorType == 1){<br>			if ( (int)(intersectPos.x/5.0f) % 2 == 0 ){<br>				if ( (int)(intersectPos.z/5.0f) % 2 == 0 ){<br>					diffuseColor = (float4)(0,0,0,0);<br>				}<br>			}<br>			else{<br>				if ( (int)(intersectPos.z/5.0f) % 2 != 0 ){<br>					diffuseColor = (float4)(0,0,0,0);<br>				}<br>			}<br>		}<br>		if ( traceDepth &lt; kMaxTraceDepth &amp;&amp; m-&gt;reflectivity &gt; 0 ){<br>				struct Ray reflectRay;<br>				float3 R = reflect(ray-&gt;dir, normal);<br>				reflectRay.origin = intersectPos + R*0.001;<br>				reflectRay.dir    = R;<br>				diffuseColor += m-&gt;reflectivity*raytrace(&amp;reflectRay, scene, traceDepth+1);<br>		}<br>		<br>		if ( traceDepth &lt; kMaxTraceDepth &amp;&amp; m-&gt;refractivity &gt; 0 ){<br>				struct Ray refractRay;<br>				float3 R = refract(ray-&gt;dir, normal, 0.6);<br>				if ( dot(R,normal) &lt; 0 ){<br>					refractRay.origin = intersectPos + R*0.001;<br>					refractRay.dir    = R;<br>					diffuseColor = m-&gt;refractivity*raytrace(&amp;refractRay, scene, traceDepth+1);<br>				}<br>		}<br>		<br>		for(int i = 0; i &lt; scene-&gt;lightsCount; i++){<br>			float3 L = scene-&gt;lights<span style="">.dir;<br>			float lightDist = kMaxRenderDist;<br>			if ( !scene-&gt;lights<span style="">.directional ){<br>				L = scene-&gt;lights<span style="">.pos - intersectPos ;<br>				lightDist = length(L);<br>				L = normalize(L);<br>			}<br>			<br>			float pointLit = 1;<br>			struct Ray shadowRay;<br>			shadowRay.origin = intersectPos + L*0.001;<br>			shadowRay.dir = L;<br>			t = intersect( &amp;shadowRay, scene, &amp;intersectObj, &amp;intersectObjType);<br>			if ( t &lt; lightDist ){<br>				pointLit = 0;<br>			}<br>			color += pointLit*diffuseColor*scene-&gt;lights<span style="">.color*max(0.0f,dot(normal, L));<br>		}<br>	}<br>	return clamp(color,0,1);<br>}<br><br>float3 matrixVectorMultiply(__global float* matrix, float3* vector){ <br>	float3 result;<br>	result.x = matrix[0]*((*vector).x)+matrix[4]*((*vector).y)+matrix[8]*((*vector).z)+matrix[12];<br>	result.y = matrix[1]*((*vector).x)+matrix[5]*((*vector).y)+matrix[9]*((*vector).z)+matrix[13];<br>	result.z = matrix[2]*((*vector).x)+matrix[6]*((*vector).y)+matrix[10]*((*vector).z)+matrix[14];<br>	return result;<br>}<br><br>__kernel void main( __global float4 *dst, uint width, uint height, __global float* viewTransform, __global float* worldTransforms )                                 <br>{                                                                            <br>	struct Scene scene;<br>	<br>	scene.standardMaterial = createMaterial();<br>	scene.standardMaterial.reflectivity = 0;<br>	scene.standardMaterial.computeColorType = 1;<br>	<br>	struct Material floorMaterial = createMaterial();<br>	floorMaterial.reflectivity = 0.5;<br>	floorMaterial.computeColorType = 1;<br>	<br>	struct Material ballMaterial1 = createMaterial();<br>	ballMaterial1.reflectivity = 1;<br>	ballMaterial1.color = (float4)(1,0,0,1);<br>	struct Material ballMaterial2 = createMaterial();<br>	ballMaterial2.reflectivity = 1;<br>	ballMaterial2.color = (float4)(0,0,1,1);<br>	struct Material ballMaterial3 = createMaterial();<br>	ballMaterial3.reflectivity = 1;<br>	ballMaterial3.color = (float4)(1,1,1,1);<br>	<br>	struct Material refractMaterial = createMaterial();<br>	refractMaterial.refractivity = 1;<br>	<br>	scene.spheresCount = 2;<br>	scene.spheres[0].pos = (float3)(0,0,0);<br>	scene.spheres[0].radius = 3;<br>	scene.spheres[0].m = &amp;ballMaterial1;<br>	scene.spheres[1].pos = (float3)(0,0,-0);<br>	scene.spheres[1].radius = 3;<br>	scene.spheres[1].m = &amp;ballMaterial2;<br>	<br>	scene.planesCount = 5;<br>	scene.planes[0].point = (float3)(0,-5,0);<br>	scene.planes[0].normal = (float3)(0,1,0);<br>	scene.planes[0].m      = &amp;floorMaterial;<br>	scene.planes[1].point = (float3)(0,40,0);<br>	scene.planes[1].normal = normalize((float3)(0,-1,0));<br>	scene.planes[2].point = (float3)(-40,-5,0);<br>	scene.planes[2].normal = (float3)(1,1,0);<br>	scene.planes[3].point = (float3)(40,-5,0);<br>	scene.planes[3].normal = normalize((float3)(-1,1,0));<br>	<br>	scene.planes[4].point = (float3)(0,0,0);<br>	scene.planes[4].normal = normalize((float3)(0,0,-1));<br>	scene.planes[4].m = &amp;refractMaterial;<br>	<br>	scene.lightsCount = 2;<br>	scene.lights[0].pos = (float3)(0,30,-20);<br>	scene.lights[0].directional = false;<br>	scene.lights[0].color = (float4)(1,1,1,1);<br>	scene.lights[1].pos = (float3)(0,30,20);<br>	scene.lights[1].dir = normalize((float3)(0,1,1));<br>	scene.lights[1].directional = false;<br>	scene.lights[1].color = (float4)(1,1,1,1);<br>	<br>	scene.spheres[0].pos = matrixVectorMultiply(worldTransforms, &amp;scene.spheres[0].pos);<br>	scene.spheres[1].pos = matrixVectorMultiply(worldTransforms+16, &amp;scene.spheres[1].pos);<br>	<br>	float dx = 1.0f / (float)(width);<br>	float dy = 1.0f / (float)(height);<br>	float aspect = (float)(width) / (float)(height);<br>	<br>	dst[get_global_id(0)] = (float4)(0,0,0,0);<br>	for(int i = 0; i &lt; kAntiAliasingSamples; i++){<br>		for(int j = 0; j &lt; kAntiAliasingSamples; j++){<br>				float x = (float)(get_global_id(0) % width) / (float)(width) + dx*i/kAntiAliasingSamples;<br>				float y = (float)(get_global_id(0) / width) / (float)(height) + dy*j/kAntiAliasingSamples;<br>				<br>				x = (x -0.5f)*aspect;<br>				y = y -0.5f;<br>				<br>				struct Ray r;<br>				r.origin = matrixVectorMultiply(viewTransform, &amp;(float3)(0, 0, -1));<br>				r.dir    = normalize(matrixVectorMultiply(viewTransform, &amp;(float3)(x, y, 0)) - r.origin);<br>				float4 color = raytrace(&amp;r, &amp;scene, 0);<br>				dst[get_global_id(0)] += color / (kAntiAliasingSamples*kAntiAliasingSamples) ;<br>		}<br>	}<br><br>} <br></span></span></span></span></span></span></span></span></code><br><br>The full source of the C++ program<br><br><code><br>#include <br>#include <br>#include <br>#include <br><br>#include <br>#include <br><br>const int kWidth = 1366;<br>const int kHeight = 768;<br>const bool kFullscreen = true;<br><br>size_t global_work_size = kWidth * kHeight;<br><br>float viewMatrix[16];<br><br>float sphere1Pos[3] = {0,0,10};<br>float sphere2Pos[3] = {0,0,-10};<br>float sphereVelocity = 1;<br>float sphereTransforms[2][16];<br><br>cl_command_queue queue;<br>cl_kernel kernel;<br>cl_mem buffer, viewTransform, worldTransforms;<br><br>void InitOpenCL()<br>{<br>	// 1. Get a platform.<br>	cl_platform_id platform;<br><br>	clGetPlatformIDs( 1, &amp;platform, NULL );<br>	// 2. Find a gpu device.<br>	cl_device_id device;<br><br>	clGetDeviceIDs( platform, CL_DEVICE_TYPE_GPU,<br>								1,<br>								&amp;device,<br>								NULL);<br>	// 3. Create a context and command queue on that device.<br>	cl_context context = clCreateContext( NULL,<br>											1,<br>											&amp;device,<br>											NULL, NULL, NULL);<br>	queue = clCreateCommandQueue( context,<br>													device,<br>													0, NULL );<br>	// 4. Perform runtime source compilation, and obtain kernel entry point.<br>	std::ifstream file("kernel.txt");<br>	std::string source;<br>	while(!file.eof()){<br>		char line[256];<br>		file.getline(line,255);<br>		source += line;<br>	}<br><br>	cl_ulong maxSize;<br>	clGetDeviceInfo(device, CL_DEVICE_MAX_MEM_ALLOC_SIZE , sizeof(cl_ulong), &amp;maxSize, 0);<br><br>	const char* str = source.c_str();<br>	cl_program program = clCreateProgramWithSource( context,<br>													1,<br>													&amp;str,<br>													NULL, NULL );<br>	cl_int result = clBuildProgram( program, 1, &amp;device, NULL, NULL, NULL );<br>	if ( result ){<br>		std::cout &lt;&lt; "Error during compilation! (" &lt;&lt; result &lt;&lt; ")" &lt;&lt; std::endl;<br>	}<br>	kernel = clCreateKernel( program, "main", NULL );<br>	// 5. Create a data buffer.<br>	buffer        = clCreateBuffer( context,<br>									CL_MEM_WRITE_ONLY,<br>									kWidth * kHeight *sizeof(cl_float4),<br>									NULL, 0 );<br>	viewTransform = clCreateBuffer( context,<br>									CL_MEM_READ_WRITE,<br>									16 *sizeof(cl_float),<br>									NULL, 0 );<br><br>	worldTransforms = clCreateBuffer( context,<br>									CL_MEM_READ_WRITE,<br>									16 *sizeof(cl_float)*2,<br>									NULL, 0 );<br><br>	clSetKernelArg(kernel, 0, sizeof(buffer), (void*) &amp;buffer);<br>	clSetKernelArg(kernel, 1, sizeof(cl_uint), (void*) &amp;kWidth);<br>	clSetKernelArg(kernel, 2, sizeof(cl_uint), (void*) &amp;kWidth);<br>	clSetKernelArg(kernel, 3, sizeof(viewTransform), (void*) &amp;viewTransform);<br>	clSetKernelArg(kernel, 4, sizeof(worldTransforms), (void*) &amp;worldTransforms);<br>}<br><br>void Render(int delta)<br>{<br><br>	clEnqueueNDRangeKernel(   queue,<br>							kernel,<br>							1,<br>							NULL,<br>							&amp;global_work_size,<br>							NULL, 0, NULL, NULL);<br><br>	// 7. Look at the results via synchronous buffer map.<br>	cl_float4 *ptr = (cl_float4 *) clEnqueueMapBuffer( queue,<br>											buffer,<br>											CL_TRUE,<br>											CL_MAP_READ,<br>											0,<br>											kWidth * kHeight * sizeof(cl_float4),<br>											0, NULL, NULL, NULL ); <br><br>	cl_float *viewTransformPtr = (cl_float *) clEnqueueMapBuffer( queue,<br>											viewTransform,<br>											CL_TRUE,<br>											CL_MAP_WRITE,<br>											0,<br>											16 * sizeof(cl_float),<br>											0, NULL, NULL, NULL ); <br><br>	cl_float *worldTransformsPtr = (cl_float *) clEnqueueMapBuffer( queue,<br>											worldTransforms,<br>											CL_TRUE,<br>											CL_MAP_WRITE,<br>											0,<br>											16 * sizeof(cl_float)*2,<br>											0, NULL, NULL, NULL ); <br><br><br>	memcpy(viewTransformPtr, viewMatrix, sizeof(float)*16);<br>	memcpy(worldTransformsPtr, sphereTransforms[0], sizeof(float)*16);<br>	memcpy(worldTransformsPtr+16, sphereTransforms[1], sizeof(float)*16);<br><br><br>	clEnqueueUnmapMemObject(queue, viewTransform, viewTransformPtr, 0, 0, 0);<br>	clEnqueueUnmapMemObject(queue, worldTransforms, worldTransformsPtr, 0, 0, 0);<br><br>	unsigned char* pixels = new unsigned char[kWidth*kHeight*4];<br>	for(int i=0; i &lt;  kWidth * kHeight; i++){<br>		pixels[i*4] = ptr<span style="">.s[0]*255;<br>		pixels[i*4+1] = ptr<span style="">.s[1]*255;<br>		pixels[i*4+2] = ptr<span style="">.s[2]*255;<br>		pixels[i*4+3] = 1;<br>	}<br><br>	glBindTexture(GL_TEXTURE_2D, 1);<br>	glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );<br>	glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );<br>	glTexImage2D(GL_TEXTURE_2D, 0, 4, kWidth, kHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels);<br>	delete [] pixels;<br><br>	glClearColor(1,1,1,1);<br>	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br><br>	glMatrixMode(GL_PROJECTION);<br>	glLoadIdentity();<br>	glOrtho(-1,1,1,-1,1,100);<br>	glMatrixMode(GL_MODELVIEW);<br>	   <br>	glLoadIdentity();<br>	glBegin(GL_QUADS);<br>	glTexCoord2f(0,1);<br>	glVertex3f(-1,-1,-1);<br>	glTexCoord2f(0,0);<br>	glVertex3f(-1,1,-1);<br>	glTexCoord2f(1,0);<br>	glVertex3f(1,1,-1);<br>	glTexCoord2f(1,1);<br>	glVertex3f(1,-1,-1);<br>	glEnd();<br><br>	SDL_GL_SwapBuffers();<br>	clFinish( queue );<br>}<br><br>void Update(int delta)<br>{<br>	int count;<br>	Uint8* keys = SDL_GetKeyState(&amp;count);<br><br>	float translate[3] = {0,0,0};<br>	if ( keys[SDLK_DOWN] ){<br>		translate[2] = -0.01*delta;<br>	}<br>	if ( keys[SDLK_UP] ){<br>		translate[2] = 0.01*delta;<br>	}<br>	if ( keys[SDLK_LEFT] ){<br>		translate[0] =- 0.01*delta;<br>	}<br>	if ( keys[SDLK_RIGHT] ){<br>		translate[0] = 0.01*delta;<br>	}<br><br>	int x,y;<br>	SDL_GetMouseState(&amp;x,&y);<br>	int relX = (kWidth/2.0f - x)*delta;<br>	int relY = (kHeight/2.0f - y)*delta;<br>	SDL_WarpMouse(kWidth/2.0f, kHeight/2.0f);<br><br>	glMatrixMode(GL_MODELVIEW);<br><br>	glLoadIdentity();<br>	glMultMatrixf(viewMatrix);<br>	glTranslatef(translate[0],translate[1],translate[2]); <br><br>	if ( relX != 0){<br>		glRotatef(-relX/200.0f, 0, 1, 0);<br>	}<br>	if ( relY != 0){<br>		glRotatef(-relY/200.0f, 1, 0, 0);<br>	}<br><br>	glGetFloatv(GL_MODELVIEW_MATRIX, viewMatrix);<br><br>	// Sphere Transforms<br>	glLoadIdentity();<br>	glTranslatef(0, 0, sphere1Pos[2]);<br>	glGetFloatv(GL_MODELVIEW_MATRIX, sphereTransforms[0]);<br><br>	glLoadIdentity();<br>	glTranslatef(0, 0, sphere2Pos[2]);<br>	glGetFloatv(GL_MODELVIEW_MATRIX, sphereTransforms[1]);<br><br>	sphere1Pos[2] += sphereVelocity*delta/30.0f;<br>	sphere2Pos[2] += sphereVelocity*(-1)*delta/30.0f;<br><br>	if ( sphere1Pos[2] &gt; 50 ){<br>		sphereVelocity = -1;<br>	}<br>	else if ( sphere1Pos[2] &lt; -50 ){<br>		sphereVelocity = 1;<br>	}<br>}<br><br>int main(int argc, char* argv[])<br>{<br>	InitOpenCL();<br><br>	memset(viewMatrix, 0, sizeof(float)*16);<br>	viewMatrix[0] = viewMatrix[5] = viewMatrix[10] = viewMatrix[15] = 1;<br><br><br>	SDL_Init(SDL_INIT_EVERYTHING);<br><br>	Uint32 flags = SDL_OPENGL;<br>	if ( kFullscreen ){<br>		flags |= SDL_FULLSCREEN;<br><br>		SDL_ShowCursor(0);<br>	}<br><br>	SDL_SetVideoMode(kWidth, kHeight, 32, flags);<br><br>	glEnable(GL_TEXTURE_2D);<br><br>	bool loop = true;<br>	int lastTicks = SDL_GetTicks();<br>	while(loop){<br>		int delta = SDL_GetTicks() - lastTicks;<br>		lastTicks = SDL_GetTicks();<br>		SDL_Event e;<br>		while(SDL_PollEvent(&amp;e)){<br>			if ( e.type == SDL_QUIT ){<br>				loop = false;<br>			}<br>			else if ( e.type == SDL_KEYDOWN &amp;&amp; e.key.keysym.sym == SDLK_ESCAPE){<br>				loop = false;<br>			}<br>		}<br><br>		Update(delta);<br>		Render(delta);<br><br>		std::stringstream ss;<br>		ss &lt;&lt; 1000.0f / delta ;<br>		SDL_WM_SetCaption(ss.str().c_str(), 0);<br>	}<br><br><br>	return 0;<br>}</span></span></span></code>